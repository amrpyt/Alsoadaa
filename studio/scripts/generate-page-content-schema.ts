/**
 * Generate Page Content Schema
 * 
 * Reads translations.ts and generates the pageContentCentralized schema
 * with all fields organized by page category
 * 
 * Run: npx ts-node --esm studio/scripts/generate-page-content-schema.ts
 */
// Extract translations object
const match = translationsContent.match(/export const translations[^{]*=\s*({[\s\S]*});/);
if (!match) {
    throw new Error('Could not parse translations file');
}

const translationsObj = eval(`(${match[1]})`);
const enTranslations = translationsObj.en;

// Helper to determine category from key (same logic as populate-all-translations.ts)
function getCategoryForKey(key: string): string {
    // (Copy the exact same logic from populate-all-translations.ts)
    // For brevity, using simplified version here

    if (['products', 'seasonalCalendar', 'processing', 'sorting', 'packing', 'exporting', 'aboutUs', 'contact', 'requestQuote'].includes(key)) {
        return 'navigation';
    }

    if (key.startsWith('hero') || key.startsWith('years') || key.startsWith('countries') || key.startsWith('certified') ||
        key.startsWith('containers') || key.startsWith('ourPremium') || key.startsWith('whyChoose') ||
        key.startsWith('testimonial')) {
        return 'home';
    }

    if (key.startsWith('about') || key.startsWith('ourStory') || key.startsWith('ourMission') ||
        key.startsWith('ourVision') || key.startsWith('journey')) {
        return 'about';
    }

    if (key.startsWith('getInTouch') || key.startsWith('contact') || key.startsWith('headOffice')) {
        return 'contact';
    }

    if (key === 'specifications' || key === 'packaging' || key.startsWith('product')) {
        return 'products';
    }

    if (key.startsWith('seasonal') || key.startsWith('productsAvailable') ||
        ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'].includes(key) ||
        ['citrus', 'vegetables', 'berries', 'lemons', 'grapes'].includes(key)) {
        return 'calendar';
    }

    // Group translations by category
    const translationsByCategory: Record<string, string[]> = {};
    Object.keys(enTranslations).forEach(key => {
        const category = getCategoryForKey(key);
        if (!translationsByCategory[category]) {
            translationsByCategory[category] = [];
        }
        translationsByCategory[category].push(key);
    });

    // Generate schema file
    let schemaContent = `import {defineType, defineField} from 'sanity'

/**
 * Page Content Centralized
 * AUTO-GENERATED - Do not edit manually
 * Generated by: studio/scripts/generate-page-content-schema.ts
 * 
 * Contains all page-specific text content
 */
export const pageContentCentralizedType = defineType({
  name: 'pageContentCentralized',
  title: 'üìù Page Content',
  type: 'document',
  groups: [
`;

    // Add groups for each page category
    Object.keys(categoryToSlug).forEach(category => {
        const icon = category === 'home' ? 'üè†' :
            category === 'about' ? 'üë•' :
                category === 'contact' ? 'üìû' :
                    category === 'products' ? 'üì¶' :
                        category === 'calendar' ? 'üìÖ' :
                            category === 'quote-form' ? 'üìù' : '‚öôÔ∏è';
        const title = category.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        schemaContent += `    {name: '${category}', title: '${icon} ${title}'},\n`;
    });

    schemaContent += `  ],
  fields: [
    // Page Reference
    defineField({
      name: 'pageSlug',
      title: 'Page Slug',
      type: 'string',
      description: 'URL slug of the page (e.g., /, /about, /contact)',
      validation: (rule) => rule.required(),
      initialValue: '/',
    }),
\n`;

    // Generate fields for each category
    Object.entries(categoryToSlug).forEach(([category, slug]) => {
        const keys = translationsByCategory[category] || [];
        if (keys.length === 0) return;

        schemaContent += `    // ============================================\n`;
        schemaContent += `    // ${category.toUpperCase()} PAGE (${keys.length} fields)\n`;
        schemaContent += `    // ============================================\n`;

        keys.forEach(key => {
            const fieldTitle = key
                .replace(/([A-Z])/g, ' $1')
                .replace(/^./, str => str.toUpperCase())
                .trim();

            // Arabic
            schemaContent += `    defineField({\n`;
            schemaContent += `      name: '${key}Ar',\n`;
            schemaContent += `      title: '${fieldTitle} (Arabic)',\n`;
            schemaContent += `      type: 'string',\n`;
            schemaContent += `      group: '${category}',\n`;
            schemaContent += `      hidden: ({document}) => document?.pageSlug !== '${slug}',\n`;
            schemaContent += `    }),\n`;

            // English
            schemaContent += `    defineField({\n`;
            schemaContent += `      name: '${key}En',\n`;
            schemaContent += `      title: '${fieldTitle} (English)',\n`;
            schemaContent += `      type: 'string',\n`;
            schemaContent += `      group: '${category}',\n`;
            schemaContent += `      hidden: ({document}) => document?.pageSlug !== '${slug}',\n`;
            schemaContent += `    }),\n`;

            // Russian
            schemaContent += `    defineField({\n`;
            schemaContent += `      name: '${key}Ru',\n`;
            schemaContent += `      title: '${fieldTitle} (Russian)',\n`;
            schemaContent += `      type: 'string',\n`;
            schemaContent += `      group: '${category}',\n`;
            schemaContent += `      hidden: ({document}) => document?.pageSlug !== '${slug}',\n`;
            schemaContent += `    }),\n\n`;
        });
    });

    schemaContent += `  ],
  preview: {
    select: {
      slug: 'pageSlug',
    },
    prepare({slug}) {
      return {
        title: \`üìù Content: \${slug}\`,
        subtitle: \`Page content for \${slug}\`,
      }
    },
  },
})
`;

    // Write schema file
    const outputPath = path.join(process.cwd(), 'studio', 'schemaTypes', 'pageContentCentralized.ts');
    fs.writeFileSync(outputPath, schemaContent);

    console.log(`‚úÖ Generated pageContentCentralized schema with ${Object.keys(enTranslations).length} fields`);
    console.log(`üìÑ Output: ${outputPath}`);
